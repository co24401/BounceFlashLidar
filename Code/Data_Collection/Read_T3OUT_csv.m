function Read_T3OUT_csv(filename, bin_size, global_resolution) % Read PicoQuant Unified TTTR Files
% I modified the picoharp PTU reader to make the output easier to read into
% MATLAB.  I only considered Hydraharp T3 Mode.  In future this could
% simplified to take out all other functionality.
%
% The following are the comments provided in picoquant's original script:
%
% Record type is in first column. 0 = count, 1 = marker, overflow data is 
% not recorded.
%
% Count record columns
% Type | Record Number | Timetag | TimeTag in ns | Time since last sync
%
% Marker record columns
% Type | Record Number | Marker # | Timetag | Timetag in ns | Unused
%
% This is demo code. Use at your own risk. No warranties.
% Marcus Sackrow, PicoQuant GmbH, December 2013
% Peter Kapusta, PicoQuant GmbH, November 2016
% Edited script: text output formatting changed by KAP.

% Note that marker events have a lower time resolution and may therefore appear
% in the file slightly out of order with respect to regular (photon) event records.
% This is by design. Markers are designed only for relatively coarse
% synchronization requirements such as image scanning.

% T Mode data are written to an output file [filename].out (I changed from .out to .csv -Connor)
% We do not keep it in memory because of the huge amout of memory
% this would take in case of large files. Of course you can change this,
% e.g. if your files are not too big.
% Otherwise it is best process the data on the fly and keep only the results.

% All HeaderData are introduced as Variable to Matlab and can directly be
% used for further analysis
%
% (Connor edit: Files generated by HHscanAndRecordT3.m do not add headers,
%  so I had to remove the header processing elements in this code to get
%   it to work.  As a result this function will not work on .ptu's 
%   generated through the hydraharp GUI.  Only acquisitions run through 
%   MATLAB command line)
    
    % Globals for subroutines
    global fid
    global MeasDesc_Resolution;      % Resolution for the Dtime (T3 Only)
    global MeasDesc_GlobalResolution;
    
    MeasDesc_Resolution = bin_size;
    MeasDesc_GlobalResolution = global_resolution;

    % start Main program
    %[filename, pathname]=uigetfile('*.ptu', 'T-Mode data:');  Changed this
    %to input argument for automated read-in
    %fid=fopen([pathname filename]);
    fid=fopen([filename]);

    %outfile = [pathname filename(1:length(filename)-4) '.csv'];
    outfile = [filename(1:length(filename)-4) '.csv'];
    global fpout;
    fpout = fopen(outfile,'W');

    fprintf(1,'\nWriting data to %s', outfile);
    fprintf(1,'\nThis may take a while...');

    global cnt_ph;
    global cnt_ov;
    global cnt_ma;
    cnt_ph = 0;
    cnt_ov = 0;
    cnt_ma = 0;

    ReadHT3(2);
    
    fclose(fid);
    fclose(fpout);
    fprintf(1,'Ready!  \n\n');
    fprintf(1,'\nStatistics obtained from the data:\n');
    fprintf(1,'\n%i photons, %i overflows, %i markers.',cnt_ph, cnt_ov, cnt_ma);

    fprintf(1,'\n');
end

%% Got Photon
%    TimeTag: Raw TimeTag from Record * Globalresolution = Real Time arrival of Photon
%    DTime: Arrival time of Photon after last Sync event (T3 only) DTime * Resolution = Real time arrival of Photon after last Sync event
%    Channel: Channel the Photon arrived (0 = Sync channel for T2 measurements)
function GotPhoton(TimeTag, Channel, DTime)
  global fpout;
  global RecNum;
  global MeasDesc_GlobalResolution;
  global cnt_ph;
  cnt_ph = cnt_ph + 1;

  % Edited: formatting changed by PK
  fprintf(fpout,'\n0,%10i,%i,%18.0f,%0.1f,%i', RecNum, Channel, TimeTag, (TimeTag * MeasDesc_GlobalResolution * 1e9), DTime);
end

%% Got Marker
%    TimeTag: Raw TimeTag from Record * Globalresolution = Real Time arrival of Photon
%    Markers: Bitfield of arrived Markers, different markers can arrive at same time (same record)
function GotMarker(TimeTag, Markers)
  global fpout;
  global RecNum;
  global cnt_ma;
  global MeasDesc_GlobalResolution;
  cnt_ma = cnt_ma + 1;
  % Edited: formatting changed by PK
  fprintf(fpout,'\n1,%10i,%i,%18.0f,%0.1f,0.0', RecNum, cnt_ma, TimeTag, (TimeTag * MeasDesc_GlobalResolution * 1e9));
  if (mod(cnt_ma, 1000)==1)
      disp(cnt_ma)
  end
      
end

%% Got Overflow
%  Count: Some TCSPC provide Overflow compression = if no Photons between overflow you get one record for multiple Overflows
function GotOverflow(Count)
  global fpout;
  global RecNum;
  global cnt_ov;
  cnt_ov = cnt_ov + Count;
  % Edited: formatting changed by PK
  %fprintf(fpout,'\n%10i OFL * %i', RecNum, Count);
end

%% Decoder functions

%% Read HydraHarp/TimeHarp260 T3
function ReadHT3(Version)
    global fid;
    global RecNum;
%    global TTResult_NumberOfRecords; % Number of TTTR Records in the File
    OverflowCorrection = 0;
    T3WRAPAROUND = 1024;
    
    RecNum = 0;

%    for i = 1:TTResult_NumberOfRecords
    while ~feof(fid)
        RecNum = RecNum+1;
        T3Record = fread(fid, 1, 'ubit32');     % all 32 bits:
        if isempty(T3Record)
            break
        end
        %   +-------------------------------+  +-------------------------------+
        %   |x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|  |x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|x|
        %   +-------------------------------+  +-------------------------------+
        nsync = bitand(T3Record,1023);       % the lowest 10 bits:
        %   +-------------------------------+  +-------------------------------+
        %   | | | | | | | | | | | | | | | | |  | | | | | | |x|x|x|x|x|x|x|x|x|x|
        %   +-------------------------------+  +-------------------------------+
        dtime = bitand(bitshift(T3Record,-10),32767);   % the next 15 bits:
        %   the dtime unit depends on "Resolution" that can be obtained from header
        %   +-------------------------------+  +-------------------------------+
        %   | | | | | | | |x|x|x|x|x|x|x|x|x|  |x|x|x|x|x|x| | | | | | | | | | |
        %   +-------------------------------+  +-------------------------------+
        channel = bitand(bitshift(T3Record,-25),63);   % the next 6 bits:
        %   +-------------------------------+  +-------------------------------+
        %   | |x|x|x|x|x|x| | | | | | | | | |  | | | | | | | | | | | | | | | | |
        %   +-------------------------------+  +-------------------------------+
        special = bitand(bitshift(T3Record,-31),1);   % the last bit:
        %   +-------------------------------+  +-------------------------------+
        %   |x| | | | | | | | | | | | | | | |  | | | | | | | | | | | | | | | | |
        %   +-------------------------------+  +-------------------------------+
        if special == 0   % this means a regular input channel
           true_nSync = OverflowCorrection + nsync;
           %  one nsync time unit equals to "syncperiod" which can be
           %  calculated from "SyncRate"
           GotPhoton(true_nSync, channel, dtime);
        else    % this means we have a special record
            if channel == 63  % overflow of nsync occured
              if (nsync == 0) || (Version == 1) % if nsync is zero it is an old style single oferflow or old Version
                OverflowCorrection = OverflowCorrection + T3WRAPAROUND;
                GotOverflow(1);
              else         % otherwise nsync indicates the number of overflows - THIS IS NEW IN FORMAT V2.0
                OverflowCorrection = OverflowCorrection + T3WRAPAROUND * nsync;
                GotOverflow(nsync);
              end
            end
            if (channel >= 1) && (channel <= 15)  % these are markers
              true_nSync = OverflowCorrection + nsync;
              GotMarker(true_nSync, channel);
            end
        end
    end
end

